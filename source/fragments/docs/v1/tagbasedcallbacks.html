<!--
template: docpage
title: Tag-Based Callbacks - Trio
appendToTarget: true
activeHeaderItem: 2
activeDocIndexItem: 13
-->

<h1>Tag-Based Callbacks</h1>

<p>Trio scans your composites for tags that are decorated with the <a href="/docs/v1/tagattributes#data-trio-callback">data-trio-callback</a> attribute and calls the JavaScript Node modules they name <em>asynchronously</em>, passing them a single object whose properties can be used along with <a target="_blank" href="https://cheerio.js.org/">cheerio</a>'s selector API to augment the composites with dynamic content.</p>

<ul>
    <li><em>file location</em>: root/source/callbacks</li>
    <li><em>file type/content</em>: .js/JavaScript Node Module</li>
</ul>

<blockquote class="note-tip"><p>Trio treats your project's markup as plain text, meaning there is no DOM involved and parses it using the <em>jQuery-like</em> selector API provided by the awesome <a class="doc-page__decorated-link" target="_blank" href="https://cheerio.js.org/">cheerio</a> OS library.
jQuery's selector API documentation can be found at <a target="_blank" href="https://jquery.com/">jquery.com</a>.</p></blockquote>

<figure>
<pre><code class="JavaScript">/*
moduleDependencies: ./lib/capitalize
*/
const capitalize = require("./lib/capitalize");

module.exports = ({ $tag, site }) => {
    site.articlesCount && site.articlesCatalog.forEach(item => {
        const data = item.matter.data;
        $tag.append(`
                &lt;li&gt;
                    &lt;a data-trio-link href="${item.url}"&gt;
                        ${data.title} - Posted to ${capitalize(data.category[0])} - ${item.articleDate}
                    &lt;/a&gt;
                &lt;/li&gt;
            `);
    });
};</code></pre>
<figcaption>Tag-Based Callback Example</figcaption>
</figure>

<h2>Declaring Tag-Based Callbacks In Your Markup</h2>

<p>To declare tag-based callbacks in your markup you decorate the tags you want to target in <em>template</em>, <em>fragment</em> and <em>include</em> assets with <em>data-trio-callback</em> attributes, and assign them the names of the callbacks located in the <em>root/source/callbacks</em> folder:</p>

<figure>
    <pre><code class="html">&lt;ul data-trio-callback="blogtaglist"&gt;&lt;/ul&gt;</code></pre>
    <figcaption>Declaring A Tag-Based Callback Example</figcaption>
</figure>

<p>The callbacks can then reference the decorated tags to augment them with dynamic content using the <em>$tag</em> property. See <a href="#implementing-tag-based-callbacks">Implementing Tag Based Callbacks</a> below for more information.</p>

<h2 id="implementing-tag-based-callbacks">Implementing Tag-Based Callbacks</h2>

<p>Each module must export a single function which, when called by Trio, is passed a single argument</p>
<pre><code class="javascript">{ $tag, $page, asset, site, cheerio }</code></pre>

<p>which can be <em>destructured</em></p>
<pre><code class="javascript">({ $tag, $page, asset, site, cheerio })</code></pre>
<p> to access its properties. See <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Unpacking_fields_from_objects_passed_as_function_parameter">Unpacking fields from objects passed as function parameter </a> for more information.</p>

<p>Callbacks can be implemented to run <em>synchronously</em></p>

<figure>
    <pre><code class="js">module.exports = ({ $tag, site }) => {
    site.tagsCatalog.forEach(item => {
        $tag.append(`
            &lt;li class="tag__list-item"&gt;
                &lt;a data-trio-link class="tag__list-item-link"
                href="/blog/tag/${item.tag.toLowerCase()}"&gt;${item.tag}&lt;/a&gt;
            &lt;/li&gt;
        `);
    });
};</code></pre>
<figcaption>Synchronous JavaScript Callback Example</figcaption>
</figure>

<p>or <em>asynchronously</em>, using async/await.</p>

<figure>
    <pre><code class="js">module.exports = async ({ $tag, site }) => {
    const catalog = await getCatalogFromCloud(...);
    catalog.forEach(item => {
        $tag.append(`
            &lt;li class="catalog-item__list-item"&gt;
                &lt;a data-trio-link class="catalog-item__list-item-link"
                href="/catalog/item/${item.name}"&gt;${item.price.toFixed(2)}&lt;/a&gt;
            &lt;/li&gt;
        `)
    });
};</code></pre>
<figcaption>Asynchronous JavaScript Callback Example</figcaption>
</figure>

<h2>Argument Properties</h2>

<h3>$page</h3>
<blockquote class="note-important"><p>Please note that this property was originally named <em>$</em> but was renamed to <em>$page</em> in v1.0.0-rc.5.</p></blockquote>
<p>$page is a <em>cheerio function</em>. It is equivalent to jQuery's <em>$</em> and <em>jQuery()</em> functions and can be used to return a collection of matched tags tags in the composite when you are targeting tags other than $tag.</p>
<figure>
    <pre><code class="js">module.exports = ({ $page, site }) => {
    site.tagsCatalog.forEach(item => {
        $page("ul.tag__list").append(`
            &lt;li class="tag__list-item"&gt;
                &lt;a data-trio-link class="tag__list-item-link"
                href="/blog/tag/${item.tag.toLowerCase()}"&gt;${item.tag}&lt;/a&gt;
            &lt;/li&gt;
        `);
    });
    $page("div.page-modified-date").append(new Date().toDateString());
};</code></pre>
<figcaption>Targeting A Composite's Content Using $page Example</figcaption>
</figure>

<h3>$tag</h3>
<p>$tag is a <em>cheerio wrapper</em> for the tag which was decorated with the <em>data-trio-callback</em> attribute. It can be used to target the tag with dynamic content.</p>
<figure>
    <pre><code class="js">module.exports = ({ $tag }) => {
    $tag.append(new Date().toDateString());
};</code></pre>
<figcaption>Targeting A Tag's Content Using $tag Example</figcaption>
</figure>

<h3 id="site">site</h3>
<p>site exposes the organized collection of <a href="/docs/v1/metadata#site">metadata</a> that Trio creates from your project's assets. Its catalogs - <a href="/docs/v1/metadata#frags">frags</a>, <a href="/docs/v1/metadata#articles-catalog">articlesCatalog</a>, <a href="/docs/v1/metadata#categories-catalog">categoriesCatalog</a>, <a href="/docs/v1/metadata#tags-catalog">tagsCatalog</a>, <a href="/docs/v1/metadata#data-catalog">dataCatalog</a> - as well as its other properties can be used to augment your composites with dynamic data.</p>
<figure>
    <pre><code class="js">module.exports = ({ $tag, site }) => {
    site.tagsCatalog.forEach(item => {
        $tag.append(`
            &lt;li class="tag__list-item"&gt;
                &lt;a data-trio-link class="tag__list-item-link"
                href="/blog/tag/${item.tag.toLowerCase()}"&gt;${item.tag}&lt;/a&gt;
            &lt;/li&gt;
        `);
    });
};</code></pre>
<figcaption>Targeting A Tag's Content With Data From site.tagsCatalog Example</figcaption>
</figure>

<h3 id="asset">asset</h3>
<p>asset exposes the <a href="/docs/v1/metadata#asset">metadata specific to the fragment</a>, including its <em>front matter</em>. It's catalogs - <a href="/docs/v1/metadata#related-articles-by-category">relatedArticlesByCategory</a>, <a href="/docs/v1/metadata#related-articles-by-tag">relatedArticlesByTag</a>, <a href="/docs/v1/metadata#related-articles-by-tag-flattened">relatedArticlesByTagFlattened</a> - as well as its other properties can be used to augment your composites with dynamic data.</p>
<figure>
    <pre><code class="js">module.exports = ({ $tag, asset }) => {
    const data = asset.matter.data;
    $tag.find("h1.article__title").append(data.title);
    $tag.find("span.article__category").append(`"${data.category}"`);
    $tag.find("span.article__date").append(asset.articleDate);
    $tag.find("img.article__img").attr("src", `/media/${data.image}`);
};</code></pre>
<figcaption>Targeting A Tag's Content With Data From asset Example</figcaption>
</figure>

<h2 id="declaringinternaldependencies">Declaring Internal Dependencies To Trigger Incremental Builds</h2>

<p>When building incrementally, Trio will detect that you have made modifications to your tag-based callbacks, and it will trigger a build to regenerate only those composites whose assets relate by way of their chains of dependencies to the modified callback. However, Trio will not automatically trigger a build when:</p>

<ul>
    <li>You have made modifications to modules that your tag-based callbacks might requires, such as to a library that you created in root/source/callbacks/lib.</li>
    <li>You have made modifications to JSON files in the root/source/data folder that your tag-based callbacks might require</li>
</ul>

<p>To remedy these 2 situations, you can optionally add front matter to your tag-based callbacks with the properties discussed below that will inform Trio to trigger a build whenever these internal dependencies are modified.</p>

<h3>Declaring Your Module Dependencies</h3>
<p>Declare your module dependencies using the <mark>moduleDependencies</mark> property.</p>
<figure>
<pre><code class="js">/*
moduleDependencies:
- ./lib/getDate
- ./lib/getTime
*/</code></pre>
<figcaption>Declaring Module Dependencies Example</figcaption>
</figure>

<h3>Declaring Your JSON Data File Dependencies</h3>
<p>Declare your JSON file dependencies using the <mark>dataDependencies</mark> property.</p>
<figure>
<pre><code class="js">/*
dataDependencies:
- contactInfo
- portfolio
*/</code></pre>
<figcaption>Declaring JSON File Dependencies Example</figcaption>
</figure>

<h2 id="declaringexternaldependencies">Declaring External Dependencies On Metadata To Trigger Incremental Builds</h2>

<p>When building incrementally, Trio will detect that you have made modifications to your fragment, include, template and tag-based callback assets, and it will trigger a build to regenerate only those composites whose assets relate by way of their chains of dependencies to those modified assets. However, Trio will not regenerate composites whose own assets haven't changed but which consume the metadata generated from unrelated modified assets, such as when generating pages that contain lists of other pages (e.g. blog pages, tag pages, category pages, catalog pages, portfolio pages, etc.).</p>

<p>To remedy this situation, you can add the <em>alwaysBuild</em> property to your fragment's front matter which will cause Trio to always mark this fragment as stale.</p>

<blockquote class="note-tip"><p>Using <a href="/docs/v1/collections">collections</a>, which was introduced in v2.0.0, can often eliminate having to use this.</p></blockquote>
<figure>
<pre><code class="html">&lt;!--
template: blogpage
title: Trio Blog | Official blog for Trio static site generator.
alwaysBuild: true
--&gt;</code></pre>
<figcaption>Using The Front Matter alwaysBuild Property Example</figcaption>
</figure>
<h2>See Also</h2>

<ul>
    <li><a data-trio-link href="/docs/v1/keyconcepts">Key Concepts</a></li>
    <li><a data-trio-link href="/docs/v1/fragment">Fragment</a></li>
    <li><a data-trio-link href="/docs/v1/tagattributes">Tag Attributes</a></li>
    <li><a data-trio-link href="/docs/v1/frontmatter">Front Matter</a></li>
    <li><a data-trio-link href="/docs/v1/metadata">Metadata</a></li>
    <li><a data-trio-link href="/docs/v1/incrementalbuild">Incremental Build</a></li>
    <li><a target="_blank" href="https://www.npmjs.com/package/cheerio">cheerio</a></li>
</ul>