<!--
template: docpage
title: Collections - Trio
appendToTarget: true
activeHeaderItem: 2
activeDocIndexItem: 18
socialMediaMetaTags:
- "<meta property=\"og:type\" content=\"article\">"
- "<meta property=\"og:title\" content=\"Collections\">"
- "<meta property=\"og:description\" content=\"Collections\">"
- "<meta property=\"og:url\" content=\"https://gettriossg.com/docs/v6/collections/\">"
- "<meta property=\"og:image\" content=\"https://gettriossg.com/media/trio-social-media-image.jpg\">"
- "<meta name=\"twitter:card\" content=\"summary_large_image\">"
- "<meta name=\"twitter:site\" content=\"@gettriossg\">"
- "<meta name=\"twitter:creator\" content=\"@jefftschwartz\">"
-->
<h1>Collections</h1>

<p><mark>Introduced in v2.0.0</mark></p>

<p>Collections are groups of pages that are dynamically generated by Trio that you would otherwise have to manually create yourself.</p>

<p>As an example, let's imagine that you have a team website which includes a page that lists all the team members. Information about each team member is maintained in a file named <em>root/source/data/team.json</em>. You would now like to create a detail page for every team member and render those pages when someone clicks on one of the team members in the list.</p>

<p>Without collections, you would have to manually create one fragment for each team member's detail page. If there are only a few team members then that wouldn't be too difficult. Suppose, however, there are dozens of, if not more, team members and how tedious it would be to have to manually create and maintain all those fragments.<p>

<p>That's where collections come to the rescue; they do all the "heavy lifting" for you. You only need to create one <a href="#collection-fragments">fragment</a> whose front matter declares one collection <a href="#collection-filter-functions">filter function</a> that when called by Trio returns a <a href="#collection-datasets">collection dataset</a>, which is an array that contains one collection dataset item for each member of the team. Trio will then create a "clone" of that fragment <em>in memory</em> for every collection dataset item and will expose the collection dataset item's properties for that cloned fragment to tag-based callbacks via the callback's <em>asset</em> argument, specifically as the <em>asset.collection.data</em> property.</p>

<h2 id="collection-fragments">Implementing Collection Fragments</h2>
<p>To create a collection, add a <em>collection hash</em> to a fragment's front matter and assign its <em>filterFn</em> property the name of a filter function located in the <em>/source/filters</em> folder.</p>

<figure>
<pre><code class="html">&lt;!--
template: default
title: Member |
appendToTarget: true
<mark>collection:
    filterFn: member</mark>
--&gt;

&lt;div <mark>data-trio-callback="teamMember"</mark>&gt;
    &lt;h1&gt;&lt;u&gt;Team Member&lt;/u&gt;&lt;/h1&gt;
    &lt;h2 id="name"&gt;Name: &lt;/h2&gt;
    &lt;h2 id="title"&gt;Title: &lt;/h2&gt;
    &lt;p id="bio"&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;a href="/"&gt;Main Page&lt;/a&gt;</code></pre>
<figcaption>Example: Fragment Used To Generate A Collection</figcaption>
</figure>

<blockquote class="note-tip"><p>You can also add <em>custom properties</em> to the collection hash which will be accessible in your collection's filter function.</p></blockquote>

<blockquote class="note-tip"><p>Fragments that declare collections in their front matter are always treated as <em>stale</em> and therefore do not need to be marked with <em>alwaysBuild</em>.</p></blockquote>

<h2 id="collection-datasets">Collection Datasets</h2>

<p>Collection datasets are arrays of collection dataset items that <a href="#collection-filter-functions">collection filter functions</a> return. Each collection dataset item in a collection dataset represents a single page of the collection. The total number of collection dataset items in a collection dataset determines the total number of pages that Trio will generate for the collection.</p>

<h2 id="collection_dataset_item_properties">Collection Dataset Item Properties</h2>

<p>Each collection dataset item in a collection dataset must include the following properties:</p>

<h3>pageName</h3>

<p>The name that will be used for the page, which may also include a path.</p>

<p>Trio uses the value that you assign to <em>pageName</em> for generating the path in the <em>root/source/fragments/</em> folder that the "cloned" fragment would be located in if it were actually written to disk. This allows Trio to treat the <em>in memory only "cloned" fragment</em> as if it actually was a physical file.</p>

<p>Trio uses the following algorithm to generate the path: <em>path to the fragment in which the collection is declared</em> + <em>collectionDatasetItem.pageName</em> + <em>the file name extension of the fragment (either .html or .md) in which the collection is declared</em>.</p>

<h3 id="data">data</h3>

<p>The data that is intended to be exposed to the composite's <a href="#tag-based-callbacks">tag-based callbacks</a>, which can be accessed to add dynamic content to the page. Using the team website for an example, the <em>data</em> property would be assigned a single item from the <em>root/source/data/team.json</em> file.</p>

<blockquote class="note-important"><p>Prior to v3, you were able to name this property anything as long as it adhered to JavaScript's object property naming conventions. However, this ambiguity prevented Trio from validating each dataset item. To remedy this, beginning with v3, Trio requires that this must now be named "data".</p></blockquote>
<blockquote class="note-tip"><p>You can use any of the data that is exposed by the <a href="/docs/v6/metadata#site">metadata site</a> object.</p></blockquote>
<blockquote class="note-tip"><p>You can add your own <em>custom properties</em> to collection dataset items and they will be accessible in the composite's tag-based callbacks also.</p></blockquote>

<h2 id="collection-filter-functions">Implementing Collection Filter Functions</h2>
<p>Each module must export a single function which, when called by Trio, is passed a single argument</p>
<pre><code>{ collection, site }</code></pre>

<p>which can be <em>destructured</em> (see <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Unpacking_fields_from_objects_passed_as_function_parameter">Unpacking fields from objects passed as function parameter </a> for more information)</p>
<pre><code>({ collection, site })</code></pre>
<p> to access its properties:</p>
<h3>site</h3>
<p>site exposes the organized collection of <a href="/docs/v6/metadata#site">metadata</a> that Trio creates from your project's assets. Its catalogs - <a href="/docs/v6/metadata#frags">frags</a>, <a href="/docs/v6/metadata#articles-catalog">articlesCatalog</a>, <a href="/docs/v6/metadata#categories-catalog">categoriesCatalog</a>, <a href="/docs/v6/metadata#tags-catalog">tagsCatalog</a>, <a href="/docs/v6/metadata#data-catalog">dataCatalog</a> - as well as its other properties can all be used to create a collection dataset.</p>
<h3>collection</h3>
<p>collection is a reference to the fragment's front matter's <a href="#collection-fragments">collection hash</a>.</p>

<blockquote class="note-important"><p>Filter functions are called <em>synchronously</em>.</p></blockquote>

<blockquote class="note-tip"><p>Trio uses <em>import-fresh</em> internally to import uncached collection filter functions.</p></blockquote>

<figure>
<pre><code class="javascript">module.exports = ({ <mark>site</mark>, <mark>collection</mark> }) =>
    site.dataCatalog.team.map(<mark>item</mark> =>
        ({ <mark>pageName</mark>: `${item.firstName} ${item.lastName}`, <mark>data</mark>: item }));</code></pre>
<figcaption>Example: Filter Function Returning A Collection Dataset</figcaption>
</figure>

<h2>Importing Uncached Internal Module Dependencies</h2>

<p>When your filter functions have their own internal module dependencies, you should import those dependencies using <a target="_blank" href="https://www.npmjs.com/package/import-fresh"><em>import-fresh</em></a> (or some similar package) to guarantee that you are always importing fresh, uncached copies of them and they reflect your most recent changes.</p>

<figure>
<pre><code class="JavaScript"><mark>const importFresh = require('import-fresh');</mark>
<mark>const pageName = importFresh("./lib/pageName");</mark>
module.exports = ({ site, collection }) =>
    site.dataCatalog.team.map(item =>
        ({ pageName: `${<mark>pageName</mark>(item.firstName, item.lastName)}`, <mark>data</mark>: item }));</code></pre>
<figcaption>Example: Filter Function Importing Uncached Module Dependency</figcaption>
</figure>

<h2 id="tag-based-callbacks">Tag-Based Callbacks</h2>

<p>The following properties, including those from the <em>collection dataset item</em>, are exposed to tag-based callbacks via the <a href="/docs/v6/metadata#collection">asset.collection</a> property:</p>

<h3>asset.collection.pageName</h3>
<p>The name of this page that was assigned to the collection dataset item's <em>pageName</em> property.</p>
<p>See <a href="#collection_dataset_item_properties">dataset item data properties</a> above.</p>

<h3>asset.collection.data</h3>
<p>The data that was assigned to the collection dataset item's <em>data</em> property.</p>
<p>See <a href="#collection_dataset_item_properties">dataset item data properties</a> above.</p>

<h3>asset.collection.index</h3>
<p>The zero-based index of the collection dataset item that contributed its data to this page.</p>

<h3>asset.collection.totalItems</h3>
<p>The total number of collection dataset items in the collection dataset.</p>

<blockquote class="note-tip"><p>In addition to the above properties, any custom properties that you add to collection dataset items are also accessible.</p></blockquote>

<figure>
<pre><code class="javascript">module.exports = ({ $tag, <mark>asset</mark> }) => {
    const data = <mark>asset.collection.data</mark>;
    $tag.find("#name").append(`${data.firstName} ${data.lastName}`);
    $tag.find("#title").append(data.title);
    $tag.find("#bio").append(data.bio);</code></pre>
<figcaption>Example: /source/callbacks/teamMember.js Tag-Based Callback Function</figcaption>
</figure>

<h2>Demo</h2>

<p>A demo collections project is available on Github that you can copy, build, run and examine.</p>

<ul>
    <li><a target="_blank" href="https://github.com/4awpawz/team-members-collection">Demo Collections Repo</a></li>
    <li><a target="_blank" href="https://4awpawz.github.io/team-members-collection-pages/">Demo Collections Live</a></li>
</ul>

<h2>See Also</h2>

<ul>
    <li><a data-trio-link href="/docs/v6/fragment">Fragment</a></li>
    <li><a data-trio-link href="/docs/v6/metadata">Metadata</a></li>
    <li><a data-trio-link href="/docs/v6/tagbasedcallbacks">Tag-Based Callbacks</a></li>
</ul>
